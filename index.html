<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå 3D Transformer Eƒüitimi Sim√ºlasyonu</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        .panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #66ccff;
            backdrop-filter: blur(10px);
            font-size: 12px;
            color: #fff;
            z-index: 100;
        }
        #controls {
            top: 20px;
            left: 20px;
            width: 200px;
        }
        #info {
            top: 20px;
            right: 20px;
            max-width: 220px;
            font-size: 11px;
            border: 2px solid #070707;
            padding: 15px;
        }
        #showResultsButton {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background: #080808;
            border: 1px solid #ff6b6b;
            font-size: 12px;
            border-radius: 8px;
        }
        #showResultsButton:hover {
            background: rgba(5, 5, 5, 0.8);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }
        button {
            background: rgba(102, 204, 255, 0.2);
            border: 1px solid rgba(102, 204, 255, 0.5);
            color: white;
            padding: 6px 12px;
            margin: 3px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 10px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        button:hover {
            background: rgba(102, 204, 255, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 204, 255, 0.5);
        }
        #trainingInfo {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-size: 12px;
        }
        .layer-info {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #66ccff;
        }
        .active-layer {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        h2 {
            color: #66ccff;
            margin-top: 0;
            font-size: 14px;
        }
        h3 {
            color: #ff6b6b;
            margin-top: 0;
            font-size: 16px;
        }
        #notification {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #ff6b6b;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            z-index: 101;
        }
        #notification.show {
            opacity: 1;
        }
        #settings-panel {
            bottom: 20px;
            left: 20px;
            width: 250px;
            transform-origin: bottom left;
            transition: all 0.5s ease;
        }
        .collapsible {
            background-color: rgba(51, 51, 51, 0.6);
            color: white;
            cursor: pointer;
            padding: 12px;
            width: 100%;
            border: 1px solid rgba(102, 204, 255, 0.3);
            text-align: left;
            outline: none;
            font-size: 15px;
            margin-top: 5px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        .collapsible:after {
            content: '\25BC';
            font-size: 13px;
            color: white;
            float: right;
            margin-left: 5px;
        }
        .collapsible.active:after {
            content: '\25B2';
        }
        .content {
            padding: 0 18px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
            background-color: rgba(34, 34, 34, 0.6);
            border-radius: 5px;
            margin-top: 5px;
        }
        .content label {
            display: block;
            margin-top: 10px;
            color: #ddd;
        }
        .content input[type="number"], .content select, .content button {
            width: 100%;
            padding: 6px;
            margin-top: 5px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            background: rgba(68, 68, 68, 0.6);
            color: white;
            backdrop-filter: blur(3px);
        }
        #chartPopup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.6);
            z-index: 102;
            display: none;
            backdrop-filter: blur(15px);
        }
        #chartPopup h3 {
            color: #ff6b6b;
            text-align: center;
        }
        #chartPopup button {
            width: 100%;
            margin-top: 15px;
            background-color: #ff6b6b;
            border: 1px solid #ff6b6b;
            color: white;
            padding: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls" class="panel">
            <h2>üß† 3D Transformer</h2>
            <button onclick="startAnimation()">‚ñ∂Ô∏è Ba≈ülat</button>
            <button onclick="stopAnimation()">‚è∏Ô∏è Dur</button>
            <button onclick="resetAnimation()">üîÑ Sƒ±fƒ±rla</button>
            <button onclick="toggleAutoRotate()">üåÄ D√∂nd√ºr</button>
            <button onclick="toggleConnections()">üîó Baƒülantƒ±</button>
            <br>
            <label style="color: #66ccff; font-size: 11px;">Hƒ±z:</label>
            <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1" 
                    style="width: 90%; margin: 5px 0;">
        </div>
        <div id="info" class="panel">
            <h3>üìä Eƒüitim Bilgileri</h3>
            <div id="trainingInfo">
                <span id="epochInfo">Epoch: 0 / 15</span><br>
                <span id="batchInfo">Batch: 0 / 50</span>
            </div>
            <p>Hata (Loss): <span id="lossInfo">0.00</span></p>
            <p>√ñƒürenme Hƒ±zƒ±: <span id="learningRateInfo">0.00002</span></p>
            <button id="showResultsButton" onclick="toggleChartPopup()" style="display:none;">Sonu√ßlarƒ± G√∂ster</button>
            <div id="layerInfo"></div>
        </div>
        <div id="notification"></div>
        <div id="settings-panel" class="panel">
            <h3>‚öôÔ∏è Ayarlar</h3>
            <button type="button" class="collapsible">Katmanlar</button>
            <div class="content">
                <label for="addLayerSelect">Katman Ekle:</label>
                <select id="addLayerSelect">
                    <option value="Encoder">Transformer Block</option>
                    <option value="Embedding">Embedding</option>
                    <option value="Segment">Segment Embedding</option>
                    <option value="Classifier">Classifier</option>
                    <option value="Dropout">Dropout</option>
                    <option value="Pooler">CLS Pooler</option>
                </select>
                <button onclick="addLayer()">Ekle</button>
                <br>
                <label for="removeLayerSelect">Katman Sil:</label>
                <select id="removeLayerSelect"></select>
                <button onclick="removeLayer()">Sil</button>
                <br>
                <label for="selectLayer">Ayarlanacak Katman:</label>
                <select id="selectLayer"></select>
                <label for="neuronCount">Boyut / N√∂ron:</label>
                <input type="number" id="neuronCount" min="2" max="1000">
                <label for="layerSize">G√∂rsel Boyut:</label>
                <input type="number" id="layerSize" min="5" max="50">
                <label for="activationFunction">Aktivasyon Fonksiyonu:</label>
                <select id="activationFunction">
                    <option value="GELU">GELU</option>
                    <option value="ReLU">ReLU</option>
                    <option value="Tanh">Tanh</option>
                    <option value="Softmax">Softmax</option>
                    <option value="None">None</option>
                </select>
            </div>
            <button type="button" class="collapsible">Diƒüer</button>
            <div class="content">
                <label for="epochCountInput">Epok Sayƒ±sƒ±:</label>
                <input type="number" id="epochCountInput" min="1" max="20" value="15">
                <label for="batchCountInput">Batch Sayƒ±sƒ± / Epoch:</label>
                <input type="number" id="batchCountInput" min="1" max="100" value="50">
                <label for="learningRateInput">√ñƒürenme Hƒ±zƒ±:</label>
                <input type="number" id="learningRateInput" step="0.00001" min="0.00001" max="0.01" value="0.00002">
                <label for="optimizerSelect">Optimizasyon Algoritmasƒ±:</label>
                <select id="optimizerSelect">
                    <option value="Adam">Adam</option>
                    <option value="AdamW">AdamW</option>
                    <option value="SGD">SGD</option>
                    <option value="RMSprop">RMSprop</option>
                </select>
            </div>
        </div>
        <div id="chartPopup">
            <h3>üìà Eƒüitim Sonu√ßlarƒ±</h3>
            <canvas id="lossAndValidChart"></canvas>
            <button onclick="toggleChartPopup()">Kapat</button>
        </div>
    </div>
    <script>
        // Global deƒüi≈ükenler
        let scene, camera, renderer, cubes = [];
        let connections = [];
        let showConnections = true;
        let isAnimating = false;
        let autoRotate = false;
        let animationSpeed = 1;
        let controls;
        // Eƒüitim deƒüi≈ükenleri
        let epochCount = 0;
        let batchCount = 0;
        let maxEpochs = 15;
        let maxBatchesPerEpoch = 50;
        let simulatedLoss = 1.0;
        let simulatedValidationLoss = 1.0;
        let learningRate = 0.00002;
        let optimizer = 'AdamW';
        let batchLossSum = 0;
        let batchLossCount = 0;
        let initialLoss = 1.0;
        const decayRate = 0.3;
        // Grafik deƒüi≈ükenleri
        let popupChart;
        let lossHistory = [];
        let validationHistory = [];
        let epochLabels = [];
        const DEFAULT_TRANSFORMER_LAYERS = [
            {name: "Input", type: "giris", count: 1, size: 20, label: "[CLS] _______ [SEP]", color: 0xFF6384, activation: "None"},
            {name: "Tokenizer", type: "gizli", count: 1, size: 10, label: "Tokenizer", color: 0x00FF00, activation: "None"},
            {name: "Segment", type: "gizli", count: 2, size: 10, label: "Segment Embedding", color: 0xFFD700, activation: "None"},
            {name: "Embedding", type: "gizli", count: 768, size: 15, label: "Embedding (768)", color: 0x36A2EB, activation: "None"},
            {name: "PosEncoding", type: "gizli", count: 768, size: 12, label: "Pos. Encoding", color: 0x00BFFF, activation: "None"},
            {name: "Encoder1", type: "gizli", count: 12, size: 18, label: "Transformer Block 1", color: 0x9966FF, activation: "GELU"},
            {name: "Encoder2", type: "gizli", count: 12, size: 18, label: "Transformer Block 2", color: 0x9966FF, activation: "GELU"},
            {name: "Encoder3", type: "gizli", count: 12, size: 18, label: "Transformer Block 3", color: 0x9966FF, activation: "GELU"},
            {name: "Pooler", type: "gizli", count: 768, size: 14, label: "CLS Pooling", color: 0xFFCE56, activation: "Tanh"},
            {name: "Classifier", type: "gizli", count: 3, size: 20, label: "Classifier (3)", color: 0xFF9F40, activation: "Softmax"},
            {name: "Output", type: "cikis", count: 3, size: 24, label: "Sentiment (3)", color: 0xFF6384, activation: "Softmax"}
        ];
        let cnnLayers = [...DEFAULT_TRANSFORMER_LAYERS];
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            setupLighting();
            rebuildScene();
            setupControls();
            setupCollapsibleMenu();
            setupPopupChart();
            updateTrainingInfo();
            animate();
        }
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            const pointLight1 = new THREE.PointLight(0x66ccff, 0.8, 100);
            pointLight1.position.set(-30, 20, 20);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0xff6b6b, 0.8, 100);
            pointLight2.position.set(30, 20, -20);
            scene.add(pointLight2);
        }
        function rebuildScene() {
            stopAnimation();
            cubes.forEach(c => scene.remove(c));
            connections.forEach(c => scene.remove(c));
            cubes = [];
            connections = [];
            const layerLabels = scene.children.filter(obj => obj.isSprite);
            layerLabels.forEach(label => scene.remove(label));
            scene.background = new THREE.Color(0x000000);
            const totalLayers = cnnLayers.length;
            const startX = -10 * (totalLayers / 2);
            const spacing = 20;
            cnnLayers.forEach((layer, layerIndex) => {
                const x = startX + layerIndex * spacing;
                const layerCubes = [];
                if (layer.name.includes('Encoder')) {
                    const cubeSize = layer.size / 10;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            for (let k = 0; k < 3; k++) {
                                const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                                const material = new THREE.MeshPhysicalMaterial({
                                    color: layer.color,
                                    transmission: 0.8,
                                    roughness: 0.7,
                                    metalness: 0.3,
                                    emissiveIntensity: 0.5,
                                    transparent: true,
                                    opacity: 0.65,
                                    emissive: new THREE.Color(layer.color).multiplyScalar(0.3)
                                });
                                const cube = new THREE.Mesh(geometry, material);
                                cube.position.set(
                                    x + (i - 1) * cubeSize * 1.5,
                                    (j - 1) * cubeSize * 1.5,
                                    (k - 1) * cubeSize * 1.5
                                );
                                cube.userData = {
                                    layer: layer.name,
                                    layerIndex: layerIndex,
                                    originalColor: layer.color,
                                    originalOpacity: 0.4,
                                    activation: layer.activation
                                };
                                scene.add(cube);
                                layerCubes.push(cube);
                            }
                        }
                    }
                } else {
                    const cubeSize = layer.size / 15;
                    const displayCount = Math.min(layer.count, 20);
                    for (let i = 0; i < displayCount; i++) {
                        const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                        const material = new THREE.MeshPhysicalMaterial({
                            color: layer.color,
                            transmission: 0.7,
                            emissiveIntensity: 0.5,
                            roughness: 0.8,
                            metalness: 0.2,
                            transparent: true,
                            opacity: 0.65,
                            emissive: new THREE.Color(layer.color).multiplyScalar(0.3)
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        const yOffset = (i - displayCount / 2) * cubeSize * 1.5;
                        cube.position.set(x, yOffset, 0);
                        cube.userData = {
                            layer: layer.name,
                            layerIndex: layerIndex,
                            originalColor: layer.color,
                            originalOpacity: 0.65,
                            activation: layer.activation
                        };
                        scene.add(cube);
                        layerCubes.push(cube);
                    }
                }
                cubes.push(...layerCubes);
                createLayerLabel(layer.label, x, 8, 0);
            });
            createConnections();
            updateRemoveLayerSelect();
            updateSelectLayerList();
            setupLayerSettingsListeners();
            setupOtherSettingsListeners();
            loadTrainingParams();
        }
        function createLayerLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#00ffff';
            context.font = 'bold 18px Arial';
            context.textAlign = 'center';
            context.shadowColor = '#00ffff';
            context.shadowBlur = 10;
            context.fillText(text, canvas.width / 2, canvas.height / 2 + 7);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(8, 2, 1);
            scene.add(sprite);
        }
        function createConnections() {
            for (let i = 0; i < cnnLayers.length - 1; i++) {
                const currentLayer = cnnLayers[i];
                const nextLayer = cnnLayers[i + 1];
                const currentCubes = cubes.filter(cube => cube.userData.layer === currentLayer.name);
                const nextCubes = cubes.filter(cube => cube.userData.layer === nextLayer.name);
                if (currentCubes.length === 0 || nextCubes.length === 0) continue;
                currentCubes.forEach((fromCube) => {
                    const connectionCount = Math.min(nextCubes.length, Math.floor(Math.random() * 3) + 1);
                    for (let j = 0; j < connectionCount; j++) {
                        const toCube = nextCubes[Math.floor(Math.random() * nextCubes.length)];
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            fromCube.position.x, fromCube.position.y, fromCube.position.z,
                            toCube.position.x, toCube.position.y, toCube.position.z
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const material = new THREE.LineBasicMaterial({
                            color: 0x444444,
                            transparent: true,
                            opacity: 0.1,
                            linewidth: 1
                        });
                        const line = new THREE.Line(geometry, material);
                        line.userData = {
                            fromLayer: currentLayer.name,
                            toLayer: nextLayer.name,
                            active: false
                        };
                        scene.add(line);
                        connections.push(line);
                    }
                });
            }
        }
        function toggleConnections() {
            showConnections = !showConnections;
            connections.forEach(connection => {
                connection.visible = showConnections;
            });
        }
        function setupControls() {
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        function setupCollapsibleMenu() {
            const collapsibles = document.getElementsByClassName("collapsible");
            for (let i = 0; i < collapsibles.length; i++) {
                collapsibles[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    const content = this.nextElementSibling;
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    }
                });
            }
        }
        function setupPopupChart() {
            const ctx = document.getElementById('lossAndValidChart').getContext('2d');
            popupChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Eƒüitim Loss',
                        data: [],
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.2)',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointBackgroundColor: '#ff6b6b',
                        fill: false
                    }, {
                        label: 'Validasyon Loss',
                        data: [],
                        borderColor: '#66ccff',
                        backgroundColor: 'rgba(102, 204, 255, 0.2)',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointBackgroundColor: '#66ccff',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: { display: true, text: 'Epoch', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Hata Deƒüeri', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: 'white' } },
                        title: {
                            display: true,
                            text: 'Loss ve Validasyon Loss Grafiƒüi',
                            color: '#66ccff',
                            font: { size: 18 }
                        }
                    }
                }
            });
        }
        function toggleChartPopup() {
            const popup = document.getElementById('chartPopup');
            if (popup.style.display === 'block') {
                popup.style.display = 'none';
            } else {
                popup.style.display = 'block';
                popupChart.data.labels = epochLabels;
                popupChart.data.datasets[0].data = lossHistory;
                popupChart.data.datasets[1].data = validationHistory;
                popupChart.update();
            }
        }
        function addLayer() {
            const newLayerType = document.getElementById('addLayerSelect').value;
            let newLayer;
            let newNamePrefix = newLayerType;
            let counter = 1;
            while(cnnLayers.some(l => l.name.startsWith(newNamePrefix) && parseInt(l.name.slice(newNamePrefix.length)) === counter)) {
                counter++;
            }
            let newName = `${newNamePrefix}${counter}`;
            if (newLayerType === 'Encoder') {
                newLayer = { name: newName, type: "gizli", count: 12, size: 16, label: `Transformer Block ${counter}`, color: 0x9966FF, activation: "GELU" };
            } else if (newLayerType === 'Embedding') {
                newLayer = { name: newName, type: "gizli", count: 768, size: 14, label: `Embedding`, color: 0x36A2EB, activation: "None" };
            } else if (newLayerType === 'Segment') {
                newLayer = { name: newName, type: "gizli", count: 2, size: 10, label: `Segment Embedding`, color: 0xFFD700, activation: "None" };
            } else if (newLayerType === 'Classifier') {
                newLayer = { name: newName, type: "gizli", count: 3, size: 20, label: `Classifier (3)`, color: 0xFF9F40, activation: "Softmax" };
            } else if (newLayerType === 'Dropout') {
                newLayer = { name: newName, type: "gizli", count: 20, size: 8, label: `Dropout`, color: 0x9966FF, activation: "None" };
            } else if (newLayerType === 'Pooler') {
                newLayer = { name: newName, type: "gizli", count: 768, size: 12, label: `CLS Pooler`, color: 0xFFCE56, activation: "Tanh" };
            }
            cnnLayers.splice(cnnLayers.length - 1, 0, newLayer);
            rebuildScene();
            showNotification(`${newLayer.label} katmanƒ± eklendi.`);
        }
        function removeLayer() {
            const layerToRemove = document.getElementById('removeLayerSelect').value;
            const index = cnnLayers.findIndex(l => l.name === layerToRemove);
            if (index !== -1) {
                if (cnnLayers[index].type === 'giris' || cnnLayers[index].type === 'cikis') {
                    showNotification('Giri≈ü ve √áƒ±kƒ±≈ü katmanlarƒ± silinemez.');
                    return;
                }
                cnnLayers.splice(index, 1);
                rebuildScene();
                showNotification(`${layerToRemove} katmanƒ± silindi.`);
            }
        }
        function updateRemoveLayerSelect() {
            const select = document.getElementById('removeLayerSelect');
            select.innerHTML = '';
            cnnLayers.forEach(layer => {
                if (layer.type !== 'giris' && layer.type !== 'cikis') {
                    const option = document.createElement('option');
                    option.value = layer.name;
                    option.innerText = layer.label;
                    select.appendChild(option);
                }
            });
        }
        function updateSelectLayerList() {
            const select = document.getElementById('selectLayer');
            select.innerHTML = '';
            cnnLayers.forEach(layer => {
                const option = document.createElement('option');
                option.value = layer.name;
                option.innerText = layer.label;
                select.appendChild(option);
            });
            loadLayerSettings();
        }
        function setupLayerSettingsListeners() {
            const selectLayer = document.getElementById('selectLayer');
            const neuronCount = document.getElementById('neuronCount');
            const layerSize = document.getElementById('layerSize');
            const activationFunction = document.getElementById('activationFunction');
            selectLayer.onchange = loadLayerSettings;
            neuronCount.onchange = updateSelectedLayer;
            layerSize.onchange = updateSelectedLayer;
            activationFunction.onchange = updateSelectedLayer;
        }
        function setupOtherSettingsListeners() {
            document.getElementById('epochCountInput').onchange = updateTrainingParams;
            document.getElementById('batchCountInput').onchange = updateTrainingParams;
            document.getElementById('learningRateInput').onchange = updateTrainingParams;
            document.getElementById('optimizerSelect').onchange = updateTrainingParams;
        }
        function loadLayerSettings() {
            const selectedLayerName = document.getElementById('selectLayer').value;
            const layer = cnnLayers.find(l => l.name === selectedLayerName);
            if (layer) {
                document.getElementById('neuronCount').value = layer.count;
                document.getElementById('layerSize').value = layer.size;
                document.getElementById('activationFunction').value = layer.activation;
                // Tokenizer, PosEncoding, Dropout ‚Üí tamamen sabit
                const isFullyFixed = layer.name.includes('Tokenizer') || layer.name.includes('PosEncoding') || layer.name.includes('Dropout');
                // Giri≈ü/√ßƒ±kƒ±≈ü ‚Üí sadece aktivasyon sabit
                const isActivationFixed = layer.type === 'giris' || layer.type === 'cikis';
                document.getElementById('activationFunction').disabled = isFullyFixed || isActivationFixed;
                document.getElementById('neuronCount').disabled = isFullyFixed;
                document.getElementById('layerSize').disabled = isFullyFixed;
            }
        }
        function updateSelectedLayer() {
            const selectedLayerName = document.getElementById('selectLayer').value;
            const layer = cnnLayers.find(l => l.name === selectedLayerName);
            if (layer) {
                const newCount = parseInt(document.getElementById('neuronCount').value);
                const newSize = parseInt(document.getElementById('layerSize').value);
                const newActivation = document.getElementById('activationFunction').value;
                if (!isNaN(newCount)) layer.count = newCount;
                if (!isNaN(newSize)) layer.size = newSize;
                layer.activation = newActivation;
                // Etiket g√ºncellemesi
                if (layer.name.startsWith('Encoder')) {
                    layer.label = `Transformer Block (${layer.count})`;
                } else if (layer.name === 'Embedding') {
                    layer.label = `Embedding (${layer.count})`;
                } else if (layer.name === 'Segment') {
                    layer.label = `Segment Embedding (${layer.count})`;
                } else if (layer.name === 'Classifier') {
                    layer.label = `Classifier (${layer.count})`;
                } else if (layer.name === 'Input') {
                    layer.label = `Input (${layer.count})`;
                } else if (layer.name === 'Output') {
                    layer.label = `Output (${layer.count})`;
                }
                rebuildScene();
            }
        }
        function updateTrainingParams() {
            maxEpochs = parseInt(document.getElementById('epochCountInput').value) || 15;
            maxBatchesPerEpoch = parseInt(document.getElementById('batchCountInput').value) || 50;
            learningRate = parseFloat(document.getElementById('learningRateInput').value) || 0.00002;
            optimizer = document.getElementById('optimizerSelect').value || 'AdamW';
            updateTrainingInfo();
            showNotification('Eƒüitim parametreleri g√ºncellendi.');
        }
        function loadTrainingParams() {
            document.getElementById('epochCountInput').value = maxEpochs;
            document.getElementById('batchCountInput').value = maxBatchesPerEpoch;
            document.getElementById('learningRateInput').value = learningRate;
            document.getElementById('optimizerSelect').value = optimizer;
        }
        function updateTrainingInfo() {
            document.getElementById('epochInfo').innerText = `Epoch: ${epochCount} / ${maxEpochs}`;
            document.getElementById('batchInfo').innerText = `Batch: ${batchCount} / ${maxBatchesPerEpoch}`;
            document.getElementById('lossInfo').innerText = simulatedLoss.toFixed(4);
            document.getElementById('learningRateInfo').innerText = learningRate.toExponential(1);
            const layerInfoDiv = document.getElementById('layerInfo');
            layerInfoDiv.innerHTML = '';
            cnnLayers.forEach((layer, index) => {
                const p = document.createElement('div');
                p.className = `layer-info ${index === currentLayerIndex ? 'active-layer' : ''}`;
                p.innerHTML = `<strong>${layer.label}</strong><br>
                                Boyut: ${layer.count}<br>
                                Aktivasyon: ${layer.activation}`;
                layerInfoDiv.appendChild(p);
            });
        }
        let animationFrameId = null;
        let currentLayerIndex = 0;
        let batchAnimationProgress = 0;
        let maxBatchAnimationProgress = 100;
        let isForwardPass = true;
        let lastTimestamp = 0;
        function animate(timestamp) {
            if (!isAnimating) return;
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) * animationSpeed;
            lastTimestamp = timestamp;
            batchAnimationProgress += deltaTime / 20;
            if (batchAnimationProgress >= maxBatchAnimationProgress) {
                batchAnimationProgress = 0;
                if (isForwardPass) {
                    highlightConnections(cnnLayers[currentLayerIndex], cnnLayers[currentLayerIndex + 1], true);
                    currentLayerIndex++;
                    if (currentLayerIndex >= cnnLayers.length - 1) {
                        isForwardPass = false;
                        const noise = (Math.random() - 0.5) * 0.02;
                        simulatedLoss = Math.max(0.01, initialLoss * Math.exp(-epochCount * decayRate) + noise);
                        simulatedValidationLoss = Math.max(0.01, initialLoss * Math.exp(-epochCount * decayRate * 0.9) + noise * 1.2);
                        batchLossSum += simulatedLoss;
                        batchLossCount++;
                        updateTrainingInfo();
                        if (validationHistory.length > 2 &&
                            validationHistory[validationHistory.length - 1] > validationHistory[validationHistory.length - 2] &&
                            lossHistory.length > 2 &&
                            lossHistory[lossHistory.length - 1] < lossHistory[lossHistory.length - 2]) {
                            showNotification("‚ö†Ô∏è Overfitting olabilir!", true);
                        }
                    }
                } else {
                    highlightConnections(cnnLayers[currentLayerIndex - 1], cnnLayers[currentLayerIndex], false);
                    currentLayerIndex--;
                    if (currentLayerIndex <= 0) {
                        isForwardPass = true;
                        batchCount++;
                        if (batchCount > maxBatchesPerEpoch) {
                            batchCount = 1;
                            epochCount++;
                            simulatedLoss = batchLossSum / maxBatchesPerEpoch;
                            lossHistory.push(simulatedLoss);
                            validationHistory.push(simulatedValidationLoss);
                            epochLabels.push(`Epok ${epochCount}`);
                            batchLossSum = 0;
                            showNotification(`Epok ${epochCount} tamamlandƒ±.`);
                        }
                        if (epochCount > maxEpochs) {
                            stopAnimation();
                            showNotification('Eƒüitim Tamamlandƒ±!', true);
                            document.getElementById('showResultsButton').style.display = 'block';
                            return;
                        }
                        updateTrainingInfo();
                    }
                }
            }
            controls.update();
            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(animate);
        }
        function highlightConnections(fromLayer, toLayer, isForward) {
            const color = isForward ? new THREE.Color(0xffffff) : new THREE.Color(0xff6b6b);
            connections.forEach(line => {
                if (line.userData.fromLayer === fromLayer.name && line.userData.toLayer === toLayer.name) {
                    line.material.color.set(color);
                    line.material.opacity = 0.8;
                    line.userData.active = true;
                } else if (line.userData.active) {
                    line.material.color.set(0x444444);
                    line.material.opacity = 0.1;
                    line.userData.active = false;
                }
            });
            cubes.forEach(cube => {
                if (cube.userData.layer === toLayer.name) {
                    cube.material.opacity = 1.0;
                    cube.material.emissive.setHex(cube.userData.originalColor);
                    cube.material.emissiveIntensity = 0.8;
                } else {
                    cube.material.opacity = cube.userData.originalOpacity;
                    cube.material.emissive.setHex(0);
                }
            });
        }
        function showNotification(message, isFinal = false) {
            const notification = document.getElementById('notification');
            notification.innerText = message;
            if (isFinal) {
                notification.style.color = '#fff';
                notification.style.background = '#ff6b6b';
            } else {
                notification.style.color = '#ff6b6b';
                notification.style.background = 'rgba(0, 0, 0, 0.7)';
            }
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            animationFrameId = requestAnimationFrame(animate);
            showNotification('Eƒüitim ba≈üladƒ±!');
        }
        function stopAnimation() {
            if (!isAnimating) return;
            isAnimating = false;
            cancelAnimationFrame(animationFrameId);
            showNotification('Eƒüitim duraklatƒ±ldƒ±.');
        }
        function resetAnimation() {
            stopAnimation();
            epochCount = 0;
            batchCount = 0;
            simulatedLoss = 1.0;
            simulatedValidationLoss = 1.0;
            currentLayerIndex = 0;
            isForwardPass = true;
            batchLossSum = 0;
            batchLossCount = 0;
            lossHistory = [];
            validationHistory = [];
            epochLabels = [];
            document.getElementById('showResultsButton').style.display = 'none';

            // üîÅ Katman yapƒ±sƒ±nƒ± orijinal haline d√∂nd√ºr (derin kopya ile)
            cnnLayers = JSON.parse(JSON.stringify(DEFAULT_TRANSFORMER_LAYERS));

            rebuildScene();
            showNotification('Sim√ºlasyon sƒ±fƒ±rlandƒ±.');
        }
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            controls.update();
            showNotification(`Otomatik d√∂nd√ºrme ${autoRotate ? 'a√ßƒ±k' : 'kapalƒ±'}.`);
        }
        init();
    </script>
</body>
</html>